

## Convert a "rows font" text file to a "columns font" suitable for the SSD1306


def reverse_string(chars):
    return chars[::-1]


## The existing font I have is the IBM VGA 8x16, which is 8 bits wide and 16 bits tall.
#   This means we need 16 bytes per glyph
#

rows_first_font_file = "font_rom_rows.txt"
cols_first_font_file = "../software/src/ssd1306_font.h"

with open(rows_first_font_file, "r") as rf:
    # read the whole file in
    old_font_rom = rf.readlines()

    total_glyphs = int(len(old_font_rom)/16)    # each glpyh 16 pixels high

    ## REDUCE FONT ROM SIZE TO SEE STUFF IN THE TERMINAL (TEMPORARY)
    total_glyphs = int(total_glyphs/2)



    print(f"total_glyphs = {total_glyphs}")


    # Each char in the new font is 8 bytes, with 1 byte per column
    new_font = []


    for i in range(total_glyphs):
        # get the relevant 16 lines
        # python slicing is not like HDL!
        old_char       = old_font_rom[16*i  :16*i+16]
        old_char_upper = old_font_rom[16*i  :16*i+8]
        old_char_lower = old_font_rom[16*i+8:16*i+16]

        # iterate over each row 8 times, assembling each column dynamically
        print(f"Starting font glyph {i}")
        for row in old_char:
            print(f"{row[:-1]}")


        ## Convert Upper half
        # Original Format
        #   0,0 0,1 0,2 ... 0,7 (one row)
        #   1,0 1,1 1,2 ... 1,7
        #   ...
        #   7,0 7,1 7,2 ... 7,7
        #
        # New Format
        #   0,0 1,0 2,0 ... 7,0 (one column)
        #   0,1 1,1 2,1 ... 7,1
        #   0,7 1,7 2,7 ... 7,7

        ## Original format has data  as old_char[i][j]
        ## UPPER
        for j in range(0,8):
            byte = ""
            # we move along the [i] dimension of the old font
            # to get the new font column
            # for i in range(0,8):
            for i in range(0,8):
                byte += old_char[i][j]
            byte = reverse_string(byte)
            byte_num = int(byte,2)
            byte_hex = hex(byte_num)    # this is probably fine for C
            print(f"byte {j}: {byte} ({byte_hex}) formatted = {byte_num:#04x}")
            new_font.append(byte_hex)   # add to our list
        ## LOWER
        for j in range(0,8):
            byte = ""
            # we move along the [i] dimension of the old font
            # to get the new font column
            for i in range(8,16):
                byte += old_char[i][j]

            byte = reverse_string(byte)
            byte_num = int(byte,2)
            byte_hex = hex(byte_num)    # this is probably fine for C
            print(f"byte {j}: {byte} ({byte_hex}) formatted = {byte_num:#04x}")
            new_font.append(byte_hex)   # add to our list

with open(cols_first_font_file, "w") as wf:
    #   At this point, new_font contains a list of all our font data (in bytes)
    #   Now lets write it out to a file (.h)

    wf.write("#ifndef _OLED_ASCII_FONT_H_\n")
    wf.write("#define _OLED_ASCII_FONT_H_\n")
    wf.write("/* \n")
    wf.write(" * This file is autogenerated by /tools/convert_font.py\n")
    wf.write(" * It contains a 16x8 ASCII font in a ' byte = 8bit column' \n")
    wf.write(" * format. The upper half of the character is located before \n")
    wf.write(" * the lower half\n")
    wf.write(" * \n")
    wf.write(" * Each glyph consists of 2 strips of 8 bytes\n")
    wf.write(" * (each byte is 8 pixels tall, LSB at the top)\n")
    wf.write(" * Total memory usage is 16 bytes per glyph\n")
    wf.write(" */ \n")

    wf.write(f"#define NUM_GLYPHS {total_glyphs}\n")
    wf.write("char font_data[NUM_GLYPHS * 16] = {\n")
    for byte in new_font:
        wf.write(f"{byte},\n")
    wf.write("};\n")
    wf.write("\n")
    wf.write("\n")



    wf.write("#endif //_OLED_ASCII_FONT_H_\n")


test_bits = "01234567"
rev_bits = reverse_string(test_bits)
print(f"TEST: {test_bits} -> {rev_bits}")








